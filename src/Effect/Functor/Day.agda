{-# OPTIONS --without-K --safe #-}

module Effect.Functor.Day where

open import Level
open import Relation.Binary using (Rel; Setoid; IsEquivalence) renaming (_⇒_ to _Rel⇒_)
open import Relation.Binary.PropositionalEquality as ≡
    using (_≡_)
import Relation.Binary.Reasoning.Setoid as ≈-Reasoning

import Relation.Binary.Construct.Closure.Equivalence as EqCl
open EqCl using (EqClosure)

import Data.Product as Prod
open Prod using (Σ; _,_; _×_; _,′_; proj₁; proj₂)
open import Function as F using (_∘_; _∘′_; id)
open import Effect.Functor
open import Effect.Functor.Law

record Day
  {a fa ga : Level}
  (F : Set a → Set fa)
  (G : Set a → Set ga)
  (X : Set a) : Set (suc a ⊔ fa ⊔ ga) where
  constructor day
  field
    Hidden : Set a
    comp₁ : F (Hidden → X)
    comp₂ : G Hidden

open Day

rawFunctor : ∀ {a fa ga} {F : Set a → Set fa} {G : Set a → Set ga}
  → RawFunctor F → RawFunctor (Day F G)
rawFunctor {a = a} {F = F} {G = G} rawF = record
  {
    _<$>_ = mapDay
  }
  where
    module FF = RawFunctor rawF
    mapDay : ∀ {X Y : Set a} → (X → Y) → Day F G X → Day F G Y
    mapDay f (day A fax ga) = day A (f ∘′_ FF.<$> fax) ga

module _ {a fa ga}
  {Fi : Set a → Setoid fa fa}
  (functorF : FunctorS Fi)
  {Gi : Set a → Setoid ga ga}
  (functorG : FunctorS Gi)
  where
    open unpack Fi
      renaming (F to F; _≈_ to infix 3 _≈₁_; isEquivalence to isEquivalence₁)
    open unpack Gi
      renaming (F to G; _≈_ to infix 3 _≈₂_; isEquivalence to isEquivalence₂)
    open IsEquivalence {{...}}
    
    module FF = Functor functorF 
    module FG = Functor functorG

    instance
      dayRawFunctor : RawFunctor (Day F G)
      dayRawFunctor = rawFunctor FF.rawFunctor
    open RawFunctor {{...}}

    -- Which equality (_≈_) should be used between two `Day F G X` values `(u, v)`?
    -- 
    -- > u = day A (F (A → X) ∋ uF) (G A ∋ uG)
    -- > v = day B (F (B → X) ∋ vF) (G B ∋ vG)
    -- 
    -- Of course, equality as a dependent product can be defined:
    
    record TooStrictEq {X : Set a} (u v : Day F G X) : Set (suc a ⊔ fa ⊔ ga) where
      constructor mkStrictEq
      field
        A≡B : u .Hidden ≡ v .Hidden
        uF≈vF : ≡.subst (λ T → F (T → X)) A≡B (u .comp₁) ≈₁ v .comp₁
        uG≈vG : ≡.subst G A≡B (u .comp₂) ≈₂ v .comp₂
    
    -- But, as the name suggests, `TooStrictEq` is not what we want when defining
    -- Day convolution of `Functor`s. The `Hidden` type component of
    -- is intended to be kept abstract when consuming `Day F G X`.
    -- Such restriction can be represented by considering `Day F G X` as a `Setoid`
    -- with equivalence relation generated by the following _⊏_ relation.
    -- 
    --   For any function `link : A → B`, `u ⊏ v` if
    --   the two values are of this form:
    --   > u = day B x (link <$> y)
    --   > v = day A (_∘′ link <$> x) y
    -- 
    -- Incorporating _≈₁_ and _≈₂_ so that `ToStrictEq ⇒ _⊏_` hold,
    -- we get the following definition:
    record _⊏_ {X : Set a} (u v : Day F G X) : Set (suc a ⊔ fa ⊔ ga) where
      constructor mk⊏

      open Day u renaming (Hidden to A; comp₁ to uF; comp₂ to uG)
      open Day v renaming (Hidden to B; comp₁ to vF; comp₂ to vG)
      
      field
        link : A → B
        ≈F : uF ≈₁ _∘′ link <$> vF
        ≈G : link <$> uG ≈₂ vG
    
    mk⊏-id : {A X : Set a} {uF vF : F (A → X)} {uG vG : G A}
      → uF ≈₁ vF → uG ≈₂ vG → day A uF uG ⊏ day A vF vG
    mk⊏-id {uF = uF} {vF = vF} {uG = uG} {vG = vG} eqF eqG =
      mk⊏ F.id (trans eqF (sym (FF.<$>-id vF))) (trans (FG.<$>-id uG) eqG)
    
    TooStrictEq⇒⊏ : {X : Set a} → TooStrictEq {X} Rel⇒ _⊏_ {X}
    TooStrictEq⇒⊏ {X} {u} {v} (mkStrictEq ≡.refl ≈F ≈G) = mk⊏-id ≈F ≈G
    
    -- The _⊏_ relation is not equivalence relation by itself.
    -- (It _is_ preorder though, but this fact does not make any subsequent proof easier.)
    -- Therefore, the appropriate _≈_ is the symmetric reflexive transitive closure
    -- of _⊏_.

    Day-setoid : (X : Set a) → Setoid (suc a ⊔ fa ⊔ ga) (suc a ⊔ fa ⊔ ga)
    Day-setoid X = EqCl.setoid (_⊏_ {X = X})

    infix 3 _≈_

    _≈_ : {X : Set a} → Rel (Day F G X) (suc a ⊔ fa ⊔ ga)
    _≈_ {X} = Setoid._≈_ (Day-setoid X)

    instance
      ≈-isEquivalence : {X : Set a} → IsEquivalence (_≈_ {X = X})
      ≈-isEquivalence {X} = Setoid.isEquivalence (Day-setoid X)

    <$>-cong-⊏ : {X Y : Set a} (f : X → Y) {u v : Day F G X} → u ⊏ v → (f <$> u) ⊏ (f <$> v)
    <$>-cong-⊏ {X = X} {Y = Y} f {u = u} {v = v} Luv = mk⊏ link eqF' eqG
      where
        open Day u renaming (Hidden to A; comp₁ to uF; comp₂ to uG)
        open Day v renaming (Hidden to B; comp₁ to vF; comp₂ to vG)
        open _⊏_ Luv renaming (link to link; ≈F to eqF; ≈G to eqG)
        eqF' : (f ∘′_ <$> uF) ≈₁ _∘′ link <$> (f ∘′_ <$> vF)
        eqF' =
          begin
            (f ∘′_ <$> uF)
          ≈⟨ FF.<$>-cong _ eqF ⟩
            (f ∘′_ <$> (_∘′ link <$> vF))
          ≈⟨ FF.<$>-∘ (f ∘′_) (_∘′ link) vF ⟩
            ((λ h → f ∘′ h ∘′ link) <$> vF)
          ≈⟨ FF.<$>-∘ (_∘′ link) (f ∘′_) vF ⟨
            (_∘′ link <$> (f ∘′_ <$> vF))
          ∎
          where open ≈-Reasoning (Fi (A → Y))

    <$>-cong : {X Y : Set a} (f : X → Y) {u₁ u₂ : Day F G X} → u₁ ≈ u₂ → f <$> u₁ ≈ f <$> u₂
    <$>-cong f = EqCl.gmap (f <$>_) (<$>-cong-⊏ f)

    -- utility

    <$>-id : {X : Set a} (u : Day F G X) → F.id <$> u ≈ u
    <$>-id u = EqCl.return (mk⊏-id (FF.<$>-id _) refl)

    <$>-∘ : {X Y Z : Set a} (f : Y → Z) (g : X → Y) (u : Day F G X)
      → f <$> (g <$> u) ≈ (f ∘′ g) <$> u
    <$>-∘ f g u = EqCl.return (mk⊏-id (FF.<$>-∘ (f ∘′_) (g ∘′_) _) refl)

    isFunctor : IsFunctorS Day-setoid dayRawFunctor
    isFunctor = record {
          <$>-cong = <$>-cong;
          <$>-id = <$>-id;
          <$>-∘ = <$>-∘
        }

    functor : FunctorS Day-setoid
    functor = record { isFunctor = isFunctor }