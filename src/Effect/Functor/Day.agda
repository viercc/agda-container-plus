{-# OPTIONS --without-K --safe #-}

module Effect.Functor.Day where

open import Level
open import Relation.Binary using (Rel; Setoid; IsEquivalence) renaming (_⇒_ to _Rel⇒_)
open import Relation.Binary.PropositionalEquality as ≡
    using (_≡_; _≗_)
import Relation.Binary.Reasoning.Setoid as ≈-Reasoning

import Relation.Binary.Construct.Closure.Equivalence as EqCl
open EqCl using (EqClosure)

import Data.Product as Prod
open Prod using (Σ; _,_; _×_; _,′_; proj₁; proj₂)
open import Function as F using (_∘_; _∘′_; id)
open import Effect.Functor
open import Effect.Functor.Law

module _
  {a fa b gb : Level}
  (F : Set a → Set fa)
  (G : Set b → Set gb) where

  record Day {x : Level} (X : Set x) : Set (suc (a ⊔ b) ⊔ fa ⊔ gb ⊔ x) where
    constructor day
    field
      A : Set a
      B : Set b
      op : A × B → X
      comp₁ : F A
      comp₂ : G B

  mapDay : ∀ {x} {X Y : Set x} → (X → Y) → Day X → Day Y
  mapDay f (day A B op fa gb) = day A B (f ∘′ op) fa gb

  rawFunctor : ∀ {x} → RawFunctor {ℓ = x} Day
  rawFunctor = record { _<$>_ = mapDay }

module _ {a a' b b' x : Level}
  {Fi : Set a → Setoid a' a'}
  (functorF : FunctorS Fi)
  {Gi : Set b → Setoid b' b'}
  (functorG : FunctorS Gi)
  where
    open unpack Fi
      renaming (F to F; _≈_ to infix 3 _≈₁_; isEquivalence to isEquivalence₁)
    open unpack Gi
      renaming (F to G; _≈_ to infix 3 _≈₂_; isEquivalence to isEquivalence₂)
    open IsEquivalence {{...}}
    
    module FF = Functor functorF 
    module FG = Functor functorG

    instance
      dayRawFunctor : RawFunctor {ℓ = x} (Day F G)
      dayRawFunctor = rawFunctor F G {x = x}
    open RawFunctor {{...}}

    x' : Level
    x' = suc (a ⊔ b) ⊔ a' ⊔ b' ⊔ x

    -- Which equality (_≈_) should be used between two `Day F G X` values `(u, v)`?
    -- 
    -- > u = day A  B  op  fa  gb
    -- > v = day A' B' op' fa' gb'
    -- 
    -- Of course, equality as a dependent product can be defined:
    
    data TooStrictEq {X : Set x} : Rel (Day F G X) x' where
      mkStrictEq : ∀ {A : Set a} {B : Set b}
        → {op₁ op₂ : A × B → X} {fa₁ fa₂ : F A} {gb₁ gb₂ : G B}
        → op₁ ≗ op₂ → fa₁ ≈₁ fa₂ → gb₁ ≈₂ gb₂
        → TooStrictEq (day A B op₁ fa₁ gb₁) (day A B op₂ fa₂ gb₂)
    
    -- But, as the name suggests, `TooStrictEq` is not what we want when defining
    -- Day convolution of `Functor`s. `A` and `B`, the two type parameters `Day` sums over,
    -- is intended to be kept abstract when consuming `Day F G X`.
    -- Such restriction can be represented by considering `Day F G X` as a `Setoid`
    -- with equivalence relation generated by the following _⊏_ relation.
    
    infix 3 _⊏_

    data _⊏_ {X : Set x} : Rel (Day F G X) x' where
      congF : ∀ {A} {B} {op : A × B → X} {fa fa' : F A} {gb : G B}
        → fa ≈₁ fa' → day A B op fa gb ⊏ day A B op fa' gb
      
      congG : ∀ {A} {B} {op} {fa : F A} {gb gb' : G B}
        → gb ≈₂ gb' → day A B op fa gb ⊏ day A B op fa gb'
      
      link : ∀ {A A' : Set a} {B B' : Set b}
        (linkA : A → A') (linkB : B → B')
        {op : A × B → X} {op' : A' × B' → X }
        → (op ≗ op' ∘′ Prod.map linkA linkB)
        → { fa : F A } { gb : G B }
        → day A B op fa gb ⊏ day A' B' op' (linkA <$> fa) (linkB <$> gb) 
    
    -- The _⊏_ relation is not equivalence relation by itself.
    -- Therefore, the appropriate _≈_ is the symmetric reflexive transitive closure
    -- of _⊏_.

    Day-setoid : (X : Set x) → Setoid _ _
    Day-setoid X = EqCl.setoid (_⊏_ {X = X})

    infix 3 _≈_

    _≈_ : {X : Set x} → Rel (Day F G X) _
    _≈_ {X} = Setoid._≈_ (Day-setoid X)
    
    instance
      ≈-isEquivalence : {X : Set x} → IsEquivalence (_≈_ {X = X})
      ≈-isEquivalence {X = X} = Setoid.isEquivalence (Day-setoid X)

    TooStrictEq⇒≈ : {X : Set x} → TooStrictEq {X} Rel⇒ _≈_ {X}
    TooStrictEq⇒≈
      {X = X}
      {x = day A B op fa gb}
      {y = day _ _ op' fa' gb'}
      (mkStrictEq op≗ ≈F ≈G) =
      begin
        day A B op fa gb
      ≈⟨ EqCl.return (link F.id F.id op≗) ⟩
        day A B op' (F.id <$> fa) (F.id <$> gb)
      ≈⟨ EqCl.return (congF (trans (FF.<$>-id fa) ≈F)) ⟩
        day A B op' fa' (F.id <$> gb)
      ≈⟨ EqCl.return (congG (trans (FG.<$>-id gb) ≈G)) ⟩
        day A B op' fa' gb'
      ∎
      where open ≈-Reasoning (Day-setoid X)
    
    <$>-cong-⊏ : {X Y : Set x} (f : X → Y) {u v : Day F G X} → u ⊏ v → (f <$> u) ⊏ (f <$> v)
    <$>-cong-⊏ _ (congF ≈F) = congF ≈F
    <$>-cong-⊏ _ (congG ≈G) = congG ≈G
    <$>-cong-⊏ f (link linkA linkB op≗) = link linkA linkB (λ ab → ≡.cong f (op≗ ab))

    <$>-cong : {X Y : Set x} (f : X → Y) {u₁ u₂ : Day F G X} → u₁ ≈ u₂ → f <$> u₁ ≈ f <$> u₂
    <$>-cong f = EqCl.gmap (f <$>_) (<$>-cong-⊏ f)

    <$>-id : {X : Set x} (u : Day F G X) → F.id <$> u ≈ u
    <$>-id u = refl

    <$>-∘ : {X Y Z : Set x} (f : Y → Z) (g : X → Y) (u : Day F G X)
      → f <$> (g <$> u) ≈ (f ∘′ g) <$> u
    <$>-∘ f g u = refl

    isFunctor : IsFunctorS Day-setoid dayRawFunctor
    isFunctor = record {
          <$>-cong = <$>-cong;
          <$>-id = <$>-id;
          <$>-∘ = <$>-∘
        }

    functor : FunctorS Day-setoid
    functor = record { isFunctor = isFunctor }