{-# OPTIONS --without-K --safe #-}

module Effect.Functor.Day where

open import Level
open import Relation.Binary using (Rel; Setoid; IsEquivalence) renaming (_⇒_ to _Rel⇒_)
open import Relation.Binary.PropositionalEquality as ≡
    using (_≡_; _≗_)
import Relation.Binary.Reasoning.Setoid as ≈-Reasoning

import Relation.Binary.Construct.Closure.Equivalence as EqCl
open EqCl using (EqClosure)

import Data.Product as Prod
open Prod using (Σ; _,_; _×_; _,′_; proj₁; proj₂)
open import Function as F using (_∘_; _∘′_; id)
open import Effect.Functor
open import Effect.Functor.Law

open IsEquivalence {{...}}
open RawFunctor {{...}}

module _
  {a fa b gb : Level}
  (F : Set a → Set fa)
  (G : Set b → Set gb) where

  record Day {x : Level} (X : Set x) : Set (suc (a ⊔ b) ⊔ fa ⊔ gb ⊔ x) where
    constructor day
    field
      {A} : Set a
      {B} : Set b
      op : A × B → X
      comp₁ : F A
      comp₂ : G B

  mapDay : ∀ {x} {X Y : Set x} → (X → Y) → Day X → Day Y
  mapDay f (day op fa gb) = day (f ∘′ op) fa gb

  rawFunctor : ∀ {x} → RawFunctor {ℓ = x} Day
  rawFunctor = record { _<$>_ = mapDay }

-- Constructor of `Day F G` but explicitly takes the existential types `A`, `B`
eday : ∀ {a a' b b'} {F : Set a → Set a'} {G : Set b → Set b'} {x : Level} {X : Set x}
  → (A : Set a) (B : Set b)
  → (A × B → X) → F A → G B → Day F G X
eday A B = day {A = A} {B = B}


module Law {a a' b b' x : Level}
  {Fi : Set a → Setoid a' a'}
  (functorF : FunctorS Fi)
  {Gi : Set b → Setoid b' b'}
  (functorG : FunctorS Gi) where
  open unpack Fi
    renaming (F to F; _≈_ to infix 3 _≈₁_; isEquivalence to isEquivalence₁)
  open unpack Gi
    renaming (F to G; _≈_ to infix 3 _≈₂_; isEquivalence to isEquivalence₂)
  
  private
    module FF = Functor functorF 
    module FG = Functor functorG

  instance
    dayRawFunctor : RawFunctor {ℓ = x} (Day F G)
    dayRawFunctor = rawFunctor F G {x = x}

  private
    x' : Level
    x' = suc (a ⊔ b) ⊔ a' ⊔ b' ⊔ x

  -- Which equality (_≈_) should be used between two `Day F G X` values `(u, v)`?
  -- 
  -- > u = day A  B  op  fa  gb
  -- > v = day A' B' op' fa' gb'
  -- 
  -- Of course, equality as a dependent product can be defined:
  
  data TooStrictEq {X : Set x} : Rel (Day F G X) x' where
    mkStrictEq : ∀ {A : Set a} {B : Set b}
      → {op₁ op₂ : A × B → X} {fa₁ fa₂ : F A} {gb₁ gb₂ : G B}
      → op₁ ≗ op₂ → fa₁ ≈₁ fa₂ → gb₁ ≈₂ gb₂
      → TooStrictEq (day op₁ fa₁ gb₁) (day op₂ fa₂ gb₂)
  
  -- But, as the name suggests, `TooStrictEq` is not what we want when defining
  -- Day convolution of `Functor`s. `A` and `B`, the two type parameters `Day` sums over,
  -- is intended to be kept abstract when consuming `Day F G X`.
  -- Such restriction can be represented by considering `Day F G X` as a `Setoid`
  -- with equivalence relation generated by the following _∼_ relation.
  
  infix 3 _∼_

  data _∼_ {X : Set x} : Rel (Day F G X) x' where
    congF : ∀ {A} {B}
      → (op : A × B → X) {fa fa' : F A} (_ : fa ≈₁ fa') (gb : G B)
      → day op fa gb ∼ day op fa' gb
    
    congG : ∀ {A} {B}
      → (op : A × B → X) (fa : F A) {gb gb' : G B} (_ : gb ≈₂ gb')
      → day op fa gb ∼ day op fa gb'
    
    link : ∀ {A A' : Set a} {B B' : Set b}
      (linkA : A → A') (linkB : B → B')
      {op : A × B → X} {op' : A' × B' → X }
      → (op ≗ op' ∘′ Prod.map linkA linkB)
      → (fa : F A) (gb : G B)
      → day op fa gb ∼ day op' (linkA <$> fa) (linkB <$> gb) 
  
  -- The _∼_ relation is not equivalence relation by itself.
  -- Therefore, the appropriate _≈_ is the symmetric reflexive transitive closure
  -- of _∼_.

  Day-setoid : (X : Set x) → Setoid _ _
  Day-setoid X = EqCl.setoid (_∼_ {X = X})

  infix 3 _≈_

  _≈_ : {X : Set x} → Rel (Day F G X) _
  _≈_ {X} = Setoid._≈_ (Day-setoid X)
  
  instance
    ≈-isEquivalence : {X : Set x} → IsEquivalence (_≈_ {X = X})
    ≈-isEquivalence {X = X} = Setoid.isEquivalence (Day-setoid X)

  -- _≈_ containes TooStrictEq
  TooStrictEq⇒≈ : {X : Set x} → TooStrictEq {X} Rel⇒ _≈_ {X}
  TooStrictEq⇒≈
    {X = X}
    {x = day op fa gb}
    {y = day op' fa' gb'}
    (mkStrictEq op≗ ≈F ≈G) =
    begin
      day op fa gb
    ≈⟨ EqCl.return (link F.id F.id op≗ _ _) ⟩
      day op' (F.id <$> fa) (F.id <$> gb)
    ≈⟨ EqCl.return (congF _ (trans (FF.<$>-id fa) ≈F) _) ⟩
      day op' fa' (F.id <$> gb)
    ≈⟨ EqCl.return (congG _ _ (trans (FG.<$>-id gb) ≈G)) ⟩
      day op' fa' gb'
    ∎
    where open ≈-Reasoning (Day-setoid X)
  
  <$>-cong-∼ : {X Y : Set x} (f : X → Y) {u v : Day F G X} → u ∼ v → (f <$> u) ∼ (f <$> v)
  <$>-cong-∼ _ (congF _ ≈F _) = congF _ ≈F _
  <$>-cong-∼ _ (congG _ _ ≈G) = congG _ _ ≈G
  <$>-cong-∼ f (link linkA linkB op≗ fa gb) = link linkA linkB (λ ab → ≡.cong f (op≗ ab)) fa gb

  <$>-cong : {X Y : Set x} (f : X → Y) {u₁ u₂ : Day F G X} → u₁ ≈ u₂ → f <$> u₁ ≈ f <$> u₂
  <$>-cong f = EqCl.gmap (f <$>_) (<$>-cong-∼ f)

  <$>-id : {X : Set x} (u : Day F G X) → F.id <$> u ≈ u
  <$>-id u = refl

  <$>-∘ : {X Y Z : Set x} (f : Y → Z) (g : X → Y) (u : Day F G X)
    → f <$> (g <$> u) ≈ (f ∘′ g) <$> u
  <$>-∘ f g u = refl

  isFunctor : IsFunctorS Day-setoid dayRawFunctor
  isFunctor = record {
        <$>-cong = <$>-cong;
        <$>-id = <$>-id;
        <$>-∘ = <$>-∘
      }

  functor : FunctorS Day-setoid
  functor = record { isFunctor = isFunctor }

  -- Utilities

  day-cong : ∀ {X} {A} {B} {op op' : A × B → X} {fa fa' : F A} {gb gb' : G B}
    → op ≗ op' → fa ≈₁ fa' → gb ≈₂ gb' → day op fa gb ≈ day op' fa' gb'
  day-cong eqop ≈F ≈G = TooStrictEq⇒≈ (mkStrictEq eqop ≈F ≈G)

  day-cong-op : ∀ {X} {A} {B} {op op' : A × B → X} {fa : F A} {gb : G B}
    → op ≗ op' → day op fa gb ≈ day op' fa gb
  day-cong-op eqop = day-cong eqop refl refl

  day-cong₁ : ∀ {X} {A} {B} {op : A × B → X} {fa fa' : F A} {gb : G B}
    → fa ≈₁ fa' → day op fa gb ≈ day op fa' gb
  day-cong₁ eq = EqCl.return (congF _ eq _)

  day-cong₂ : ∀ {X} {A} {B} {op : A × B → X} {fa : F A} {gb gb' : G B}
    → gb ≈₂ gb' → day op fa gb ≈ day op fa gb'
  day-cong₂ eq = EqCl.return (congG _ _ eq)

  day-link : ∀ {X} {A A'} {B B'}
    (linkA : A → A') (linkB : B → B')
    {op : A × B → X} {op' : A' × B' → X }
    → (op ≗ op' ∘′ Prod.map linkA linkB)
    → { fa : F A } { gb : G B }
    → day op fa gb ≈ day op' (linkA <$> fa) (linkB <$> gb) 
  day-link linkA linkB op≗ = EqCl.return (link linkA linkB op≗ _ _)
